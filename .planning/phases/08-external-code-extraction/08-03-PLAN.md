---
phase: 08-external-code-extraction
plan: 03
type: execute
wave: 2
depends_on: [08-01, 08-02]
files_modified:
  - packages/lsp1/package.json
  - packages/lsp1/build.config.ts
  - packages/lsp1/vitest.config.ts
  - packages/lsp1/tsconfig.json
  - packages/lsp1/README.md
  - packages/lsp1/LICENSE
  - packages/lsp1/src/index.ts
  - packages/lsp1/src/constants.ts
  - packages/lsp1/src/types.ts
  - packages/erc725/package.json
  - packages/erc725/build.config.ts
  - packages/erc725/vitest.config.ts
  - packages/erc725/tsconfig.json
  - packages/erc725/README.md
  - packages/erc725/LICENSE
  - packages/erc725/src/index.ts
  - packages/erc725/src/data-keys.ts
  - packages/erc725/src/types.ts
autonomous: true
requirements: [EXT-01, EXT-02]

must_haves:
  truths:
    - "@chillwhales/lsp1 package exists with LSP1 UniversalReceiver event constants and type definitions"
    - "@chillwhales/erc725 package exists with ERC725Y data-key building and reading utilities"
    - "Both new packages follow the standard monorepo pattern (shared build config, vitest, tsconfig)"
    - "All 11 packages build with zero warnings"
    - "All tests pass across all packages (pnpm test)"
    - "pnpm check passes (lint + sherif + knip + madge)"
    - "lsp-indexer metadata parsing overlap documented in SUMMARY"
  artifacts:
    - path: "packages/lsp1/package.json"
      provides: "LSP1 package manifest following monorepo pattern"
    - path: "packages/lsp1/src/index.ts"
      provides: "LSP1 barrel exports"
      min_lines: 5
    - path: "packages/lsp1/src/constants.ts"
      provides: "LSP1 UniversalReceiver typeId constants"
    - path: "packages/erc725/package.json"
      provides: "ERC725 package manifest"
    - path: "packages/erc725/src/index.ts"
      provides: "ERC725 barrel exports"
      min_lines: 5
    - path: "packages/erc725/src/data-keys.ts"
      provides: "ERC725Y data-key building and array key utilities"
  key_links:
    - from: "packages/lsp1/build.config.ts"
      to: "@chillwhales/config/build"
      via: "createBuildConfig import"
      pattern: "createBuildConfig"
    - from: "packages/erc725/build.config.ts"
      to: "@chillwhales/config/build"
      via: "createBuildConfig import"
      pattern: "createBuildConfig"
    - from: "pnpm build (root)"
      to: "all 11 packages"
      via: "pnpm -r build"
      pattern: "pnpm.*build"
    - from: "pnpm test (root)"
      to: "all 11 packages"
      via: "vitest projects auto-discovery"
      pattern: "packages/\\*"
---

<objective>
Create @chillwhales/lsp1 and @chillwhales/erc725 packages, investigate lsp-indexer for extractable code, and verify full integration across all 11 packages.

Purpose: Complete the Phase 8 extraction by creating the two new packages specified in the roadmap (EXT-02), incorporating any extractable code from lsp-indexer, and verifying the entire monorepo works together.

Output: Two new published packages (lsp1, erc725), lsp-indexer investigation documented, all 11 packages verified as building/testing/linting cleanly.
</objective>

<execution_context>
@/home/coder/.config/Claude/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-external-code-extraction/08-CONTEXT.md

# Reference prior plan SUMMARYs for what was extracted
@.planning/phases/08-external-code-extraction/08-01-SUMMARY.md
@.planning/phases/08-external-code-extraction/08-02-SUMMARY.md

Source repo: https://github.com/chillwhales/lsp-indexer (public)
</context>

<interfaces>
<!-- Shared build config pattern (copy exactly for new packages) -->
From packages/lsp31/build.config.ts:
```typescript
import { createBuildConfig } from "@chillwhales/config/build";
export default createBuildConfig();
```

From packages/lsp31/vitest.config.ts:
```typescript
import { createVitestConfig } from "@chillwhales/config/vitest";
export default createVitestConfig();
```

From packages/lsp31/tsconfig.json:
```json
{
  "extends": "@chillwhales/config/tsconfig",
  "compilerOptions": { "outDir": "./dist", "rootDir": "./src" },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

<!-- Package.json template (follow lsp31 pattern exactly) -->
From packages/lsp31/package.json (key fields):
```json
{
  "type": "module",
  "types": "./dist/index.d.mts",
  "exports": { ".": { "types": "./dist/index.d.mts", "default": "./dist/index.mjs" } },
  "files": ["dist", "LICENSE", "README.md"],
  "engines": { "node": ">=22" },
  "sideEffects": false,
  "scripts": { "build": "unbuild", "clean": "rm -rf dist", "test": "vitest run" },
  "devDependencies": {
    "@chillwhales/config": "workspace:*",
    "typescript": "catalog:",
    "unbuild": "catalog:",
    "vitest": "catalog:"
  },
  "packageManager": "pnpm@10.30.2"
}
```

<!-- vitest.config.ts at root — auto-discovers packages/* -->
From vitest.config.ts:
```typescript
test: { projects: ["packages/*", "!packages/config"] }
```
<!-- New packages are auto-discovered. No root config changes needed. -->
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create @chillwhales/lsp1 and @chillwhales/erc725 packages with lsp-indexer investigation</name>
  <files>
    packages/lsp1/package.json
    packages/lsp1/build.config.ts
    packages/lsp1/vitest.config.ts
    packages/lsp1/tsconfig.json
    packages/lsp1/README.md
    packages/lsp1/LICENSE
    packages/lsp1/src/index.ts
    packages/lsp1/src/constants.ts
    packages/lsp1/src/types.ts
    packages/lsp1/src/schemas.ts
    packages/lsp1/src/guards.ts
    packages/erc725/package.json
    packages/erc725/build.config.ts
    packages/erc725/vitest.config.ts
    packages/erc725/tsconfig.json
    packages/erc725/README.md
    packages/erc725/LICENSE
    packages/erc725/src/index.ts
    packages/erc725/src/data-keys.ts
    packages/erc725/src/types.ts
    packages/erc725/src/schemas.ts
  </files>
  <action>
**Step 1: Clone lsp-indexer and audit for extractable code**
```bash
git clone --depth 1 https://github.com/chillwhales/lsp-indexer.git /tmp/lsp-indexer
```

Audit `packages/indexer-v2/src/` for pure utility functions (not coupled to database, TypeORM, or batch context):
- Read `plugins/events/universalReceiver.plugin.ts` — note the event topic, decode pattern, and typeId handling. The plugin itself is NOT extractable (uses BatchContext, TypeORM entities). But the **event signature**, **topic0**, and **typeId constants** are extractable as pure constants.
- Read `plugins/events/dataChanged.plugin.ts` — same: event topic and decode pattern are extractable constants.
- Read `handlers/` directory — these are indexer-specific handlers (database writes). NOT extractable.
- Read `core/handlerHelpers.ts` — check for pure utility functions.
- Read `utils/` directory — check for pure utility functions.
- Read `constants/` directory — check for extractable constants (chillwhales addresses, LSP29 config).

**Important:** The lsp-indexer code is deeply coupled to the indexer infrastructure (TypeORM entities, BatchContext, FK enrichment queues). Most code is NOT extractable as-is. Extract only pure constants and type definitions. Create new utility functions inspired by the patterns observed.

Also investigate metadata parsing overlap (per CONTEXT.md):
- Read `handlers/lsp3ProfileFetch.handler.ts` — does it parse LSP3 metadata? Could @chillwhales/lsp3 replace that parsing?
- Read `handlers/lsp4MetadataFetch.handler.ts` — does it parse LSP4 metadata? Could @chillwhales/lsp4 replace that parsing?
- Read `handlers/lsp29EncryptedAsset.handler.ts` — does it parse LSP29 metadata? Could @chillwhales/lsp29 replace that parsing?
- Document findings in the SUMMARY (which @chillwhales/* parsers could replace indexer parsing).

**Step 2: Create @chillwhales/lsp1 package**

LSP1 is the UniversalReceiver standard — defines how Universal Profiles receive notifications about asset transfers, profile changes, etc.

Create `packages/lsp1/` with the standard monorepo pattern:

**package.json:**
```json
{
  "name": "@chillwhales/lsp1",
  "version": "0.1.0",
  "type": "module",
  "description": "LSP1 UniversalReceiver — event constants, typeId definitions, and notification type guards for LUKSO Universal Profiles",
  "author": "b00ste",
  "license": "MIT",
  "types": "./dist/index.d.mts",
  "exports": { ".": { "types": "./dist/index.d.mts", "default": "./dist/index.mjs" } },
  "files": ["dist", "LICENSE", "README.md"],
  "engines": { "node": ">=22" },
  "repository": { "type": "git", "url": "git+https://github.com/chillwhales/LSPs.git", "directory": "packages/lsp1" },
  "keywords": ["chillwhales", "lukso", "lsp", "lsp1", "universal-receiver", "notifications"],
  "sideEffects": false,
  "scripts": { "build": "unbuild", "build:watch": "unbuild --watch", "clean": "rm -rf dist", "test": "vitest run", "test:watch": "vitest" },
  "dependencies": { "zod": "catalog:" },
  "peerDependencies": { "viem": "catalog:" },
  "devDependencies": {
    "@chillwhales/config": "workspace:*",
    "typescript": "catalog:",
    "unbuild": "catalog:",
    "viem": "catalog:",
    "vitest": "catalog:"
  },
  "packageManager": "pnpm@10.30.2"
}
```

**build.config.ts, vitest.config.ts, tsconfig.json:** Copy exactly from lsp31 template (see interfaces above).

**LICENSE:** Copy from repo root: `cp LICENSE packages/lsp1/LICENSE`

**src/constants.ts:**
Define LSP1 UniversalReceiver typeId constants (these are standardized in the LUKSO ecosystem):
```typescript
/**
 * LSP1 UniversalReceiver TypeId Constants
 *
 * Standard typeIds emitted when Universal Profiles receive notifications.
 * @see https://docs.lukso.tech/standards/universal-profile/lsp1-universal-receiver
 */

/** TypeId for LSP7 token transfer received */
export const LSP1_TYPE_IDS = {
  LSP7Tokens_RecipientNotification: "0x429ac7a06903dbc9c13dfcb3c9d11df8194581fa047c96d7a4171fc7402958ea",
  LSP7Tokens_SenderNotification: "0x386072cc5a58e61263b434c722725f21031cd06e7c552cfdb02e04feecfb70c8",
  LSP8Tokens_RecipientNotification: "0x0b084a55ebf70fd3c06fd755269dac2212c4d3f0f4d09079780bfa50c1b2984d",
  LSP8Tokens_SenderNotification: "0xb23eae7e6d1564b295b4c3e3be402d9a2f0776c57bdf365903496f6fa481ab00",
  LSP14OwnershipTransferred_SenderNotification: "0xa4e59c931d14f7c8a7a35027f92ee40b5f2886b9fdcdb78f30bc5ecce5a2f814",
  LSP14OwnershipTransferred_RecipientNotification: "0xe32c7debcb817925ba4883fdbfc52797187f28f73f860641dab1a68d9b32902c",
} as const;

export type LSP1TypeId = (typeof LSP1_TYPE_IDS)[keyof typeof LSP1_TYPE_IDS];
```

If lsp-indexer audit reveals additional typeIds or constants, include them. If the UniversalReceiver plugin reveals the event signature topic, include it as `UNIVERSAL_RECEIVER_EVENT_TOPIC`.

**src/types.ts:**
```typescript
import type { z } from "zod";
import type { universalReceiverEventSchema } from "./schemas";

export type UniversalReceiverEvent = z.infer<typeof universalReceiverEventSchema>;
```

**src/schemas.ts:**
Define Zod schemas for UniversalReceiver event data:
```typescript
import { z } from "zod";

export const universalReceiverEventSchema = z.object({
  from: z.string(),
  value: z.bigint(),
  typeId: z.string(),
  receivedData: z.string(),
  returnedValue: z.string(),
});
```

Adapt based on what the lsp-indexer audit reveals about the actual event structure.

**src/guards.ts:**
```typescript
import { LSP1_TYPE_IDS } from "./constants";

export function isLsp1TypeId(value: string): boolean {
  return Object.values(LSP1_TYPE_IDS).includes(value as any);
}
```

**src/index.ts:**
```typescript
/**
 * @chillwhales/lsp1
 *
 * LSP1 UniversalReceiver Standard
 * Event constants, typeId definitions, and notification type guards.
 *
 * @see https://docs.lukso.tech/standards/universal-profile/lsp1-universal-receiver
 */

export * from "./constants";
export * from "./guards";
export * from "./schemas";
export * from "./types";
```

**README.md:** Follow lsp31 template pattern:
```markdown
# @chillwhales/lsp1

[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg)](./LICENSE)

LSP1 UniversalReceiver — event constants, typeId definitions, and notification type guards for LUKSO Universal Profiles.

## Install

\`\`\`bash
pnpm add @chillwhales/lsp1
\`\`\`

> **Peer dependency:** This package requires [`viem`](https://viem.sh) ^2.0.0

## Usage

\`\`\`typescript
import { LSP1_TYPE_IDS, isLsp1TypeId } from "@chillwhales/lsp1";

// Check if a typeId is a known LSP1 notification
if (isLsp1TypeId(event.typeId)) {
  console.log("Known LSP1 notification");
}

// Use specific typeId constants
if (event.typeId === LSP1_TYPE_IDS.LSP7Tokens_RecipientNotification) {
  console.log("Received LSP7 tokens");
}
\`\`\`
```

**Step 3: Create @chillwhales/erc725 package**

ERC725 utilities for working with ERC725Y data keys — building keys, computing array element keys, and reading contract storage.

Create `packages/erc725/` with the standard monorepo pattern:

**package.json:**
```json
{
  "name": "@chillwhales/erc725",
  "version": "0.1.0",
  "type": "module",
  "description": "ERC725Y data-key building, array key computation, and contract storage reading utilities",
  "author": "b00ste",
  "license": "MIT",
  "types": "./dist/index.d.mts",
  "exports": { ".": { "types": "./dist/index.d.mts", "default": "./dist/index.mjs" } },
  "files": ["dist", "LICENSE", "README.md"],
  "engines": { "node": ">=22" },
  "repository": { "type": "git", "url": "git+https://github.com/chillwhales/LSPs.git", "directory": "packages/erc725" },
  "keywords": ["chillwhales", "lukso", "erc725", "erc725y", "data-keys", "storage"],
  "sideEffects": false,
  "scripts": { "build": "unbuild", "build:watch": "unbuild --watch", "clean": "rm -rf dist", "test": "vitest run", "test:watch": "vitest" },
  "dependencies": { "zod": "catalog:" },
  "peerDependencies": { "viem": "catalog:" },
  "devDependencies": {
    "@chillwhales/config": "workspace:*",
    "typescript": "catalog:",
    "unbuild": "catalog:",
    "viem": "catalog:",
    "vitest": "catalog:"
  },
  "packageManager": "pnpm@10.30.2"
}
```

**build.config.ts, vitest.config.ts, tsconfig.json:** Same templates as lsp1.

**LICENSE:** `cp LICENSE packages/erc725/LICENSE`

**src/data-keys.ts:**
Core ERC725Y data-key utilities. Build from lsp-indexer patterns and ERC725Y spec knowledge:

```typescript
/**
 * ERC725Y Data Key Utilities
 *
 * Pure functions for building and parsing ERC725Y storage keys.
 * Implements the key derivation patterns from LSP2 ERC725Y JSON Schema.
 *
 * @see https://docs.lukso.tech/standards/universal-profile/lsp2-json-schema
 */

import type { Hex } from "viem";
import { concat, keccak256, pad, slice, stringToHex, toHex } from "viem";

/**
 * Compute a Singleton data key from a key name.
 * keccak256(keyName)
 */
export function computeSingletonKey(keyName: string): Hex {
  return keccak256(stringToHex(keyName));
}

/**
 * Compute an Array data key (the length key) from a key name.
 * keccak256(keyName) — same as singleton, but used for Array[] types.
 * The first 16 bytes of the keccak256 hash serve as the key prefix for elements.
 */
export function computeArrayKey(keyName: string): Hex {
  return keccak256(stringToHex(keyName));
}

/**
 * Compute an Array element key for a given index.
 * first16bytes(keccak256(keyName)) + uint128(index)
 */
export function computeArrayElementKey(keyName: string, index: number | bigint): Hex {
  const arrayKey = computeArrayKey(keyName);
  const prefix = slice(arrayKey, 0, 16);
  const indexHex = toHex(BigInt(index), { size: 16 });
  return concat([prefix, indexHex]);
}

/**
 * Compute a Mapping data key.
 * first10bytes(keccak256(keyName)) + 0000 + first20bytes(keccak256(mapKey))
 * or with address: first10bytes(keccak256(keyName)) + 0000 + address
 */
export function computeMappingKey(keyName: string, mapKey: Hex | string): Hex {
  const firstPart = slice(keccak256(stringToHex(keyName)), 0, 10);
  const padding = "0x0000" as Hex;
  // If mapKey is 20 bytes (address), use directly. Otherwise hash it.
  const secondPart = mapKey.length === 42
    ? mapKey as Hex
    : slice(keccak256(typeof mapKey === "string" ? stringToHex(mapKey) : mapKey), 0, 20);
  return concat([firstPart, padding, secondPart]);
}

/**
 * Compute a MappingWithGrouping data key.
 * first6bytes(keccak256(keyName)) + first4bytes(keccak256(firstPart)) + 0000 + first20bytes(keccak256(lastPart))
 */
export function computeMappingWithGroupingKey(
  keyName: string,
  firstPart: string,
  lastPart: Hex | string,
): Hex {
  const keyPrefix = slice(keccak256(stringToHex(keyName)), 0, 6);
  const groupHash = slice(keccak256(stringToHex(firstPart)), 0, 4);
  const padding = "0x0000" as Hex;
  const lastPartHex = lastPart.length === 42
    ? lastPart as Hex
    : slice(keccak256(typeof lastPart === "string" ? stringToHex(lastPart) : lastPart), 0, 20);
  return concat([keyPrefix, groupHash, padding, lastPartHex]);
}

/**
 * Extract the array key prefix (first 16 bytes) from a full data key.
 * Used to match array element keys against their parent array.
 */
export function extractArrayPrefix(dataKey: Hex): Hex {
  return slice(dataKey, 0, 16);
}

/**
 * Extract the element index from an Array element key.
 * Returns the uint128 index stored in the last 16 bytes.
 */
export function extractArrayIndex(elementKey: Hex): bigint {
  const indexHex = slice(elementKey, 16, 32);
  return BigInt(indexHex);
}
```

Adapt and extend based on what the lsp-indexer audit reveals. If the indexer has additional data-key patterns not covered above, add them.

**src/types.ts:**
```typescript
import type { Hex } from "viem";

/** ERC725Y key-value pair */
export interface ERC725YKeyValue {
  key: Hex;
  value: Hex;
}

/** ERC725Y key type classifications from LSP2 */
export type ERC725YKeyType = "Singleton" | "Array" | "Mapping" | "MappingWithGrouping";
```

**src/schemas.ts:**
Minimal Zod schemas for validating ERC725Y key structures if needed.

**src/index.ts:**
```typescript
/**
 * @chillwhales/erc725
 *
 * ERC725Y Data Key Utilities
 * Build, parse, and work with ERC725Y storage keys following LSP2 key derivation patterns.
 *
 * @see https://docs.lukso.tech/standards/universal-profile/lsp2-json-schema
 */

export * from "./data-keys";
export * from "./types";
```

**README.md:** Follow the template pattern with installation, usage examples showing data-key computation.

**Step 4: Run pnpm install to register new packages**
```bash
pnpm install
```

**Step 5: Build and test new packages**
```bash
pnpm --filter @chillwhales/lsp1 build
pnpm --filter @chillwhales/erc725 build
```

**Step 6: Clean up**
```bash
rm -rf /tmp/lsp-indexer
```
  </action>
  <verify>
    <automated>pnpm install && pnpm --filter @chillwhales/lsp1 build && pnpm --filter @chillwhales/erc725 build 2>&1 | tail -5</automated>
  </verify>
  <done>
    Both @chillwhales/lsp1 and @chillwhales/erc725 packages created with standard monorepo pattern. Both build with zero warnings. lsp-indexer investigated and findings noted.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write tests for new packages and run full integration verification</name>
  <files>
    packages/lsp1/src/constants.test.ts
    packages/lsp1/src/guards.test.ts
    packages/erc725/src/data-keys.test.ts
  </files>
  <action>
**Step 1: Write @chillwhales/lsp1 tests**

Create `packages/lsp1/src/constants.test.ts`:
- Verify all typeId constants are 32-byte hex strings (66 chars with 0x prefix)
- Verify LSP1_TYPE_IDS object has expected keys
- Verify type narrowing: `LSP1TypeId` type includes all values

Create `packages/lsp1/src/guards.test.ts`:
- `isLsp1TypeId` returns true for known typeIds
- `isLsp1TypeId` returns false for unknown hex strings
- `isLsp1TypeId` returns false for empty string

**Step 2: Write @chillwhales/erc725 tests**

Create `packages/erc725/src/data-keys.test.ts`:
- `computeSingletonKey` — verify produces keccak256 of the key name string
- `computeArrayKey` — verify produces same as singleton key (it's the length key)
- `computeArrayElementKey` — verify first 16 bytes match array key prefix, last 16 bytes are uint128 index
  - Test index 0, 1, large number
- `computeMappingKey` — verify first 10 bytes from keccak256(keyName), middle 2 bytes 0x0000, last 20 bytes from address or hash
  - Test with address (20 bytes) as mapKey
  - Test with string as mapKey
- `computeMappingWithGroupingKey` — verify first 6 + 4 + 2 + 20 byte structure
- `extractArrayPrefix` — verify extracts first 16 bytes
- `extractArrayIndex` — verify extracts uint128 from last 16 bytes
  - Roundtrip test: `extractArrayIndex(computeArrayElementKey("Test[]", 42n))` === `42n`

Use known ERC725Y key values from the LUKSO documentation for verification:
- `SupportedStandards:LSP3Profile` = `0xeafec4d89fa9619884b600005ef83ad9559033e6e941db7d7c495acdce616347`
- `LSP3Profile` = keccak256("LSP3Profile") = `0x5ef83ad9559033e6e941db7d7c495acdce616347d28e90c7ce47cbfcfcad3bc5`

**Step 3: Run tests for new packages**
```bash
pnpm --filter @chillwhales/lsp1 test
pnpm --filter @chillwhales/erc725 test
```

**Step 4: Full integration verification**

Run ALL checks across the entire monorepo:

```bash
# Build all 11 packages
pnpm build

# Run all tests
pnpm test

# Lint all code
pnpm check:lint

# Monorepo hygiene
pnpm sherif
pnpm knip
pnpm madge
```

If any failures:
- **Build failures** — fix TypeScript errors, missing exports, import paths
- **Test failures** — fix failing tests (may need to adjust for new packages)
- **Lint failures** — run `pnpm check:lint:fix` to auto-fix, then manually fix remaining
- **sherif failures** — fix dependency consistency issues (catalog references, version mismatches)
- **knip failures** — update `knip.json` if new packages have different entry point patterns. New packages follow `packages/*` workspace pattern so should auto-detect. If knip reports unused exports, check barrel files.
- **madge failures** — check for circular dependencies between new packages and existing ones. New packages should have minimal deps (lsp1 has none, erc725 has viem only).

**Step 5: Verify package count**
```bash
ls -d packages/*/package.json | wc -l
```
Should show 11 (config + utils + lsp2 + lsp3 + lsp4 + lsp6 + lsp23 + lsp29 + lsp31 + lsp1 + erc725).

**Step 6: Verify no marketplace/indexer artifacts remain**
```bash
# No @chillpass imports anywhere
grep -r "@chillpass" packages/*/src/ 2>/dev/null && echo "ERROR: @chillpass imports found" || echo "OK: No @chillpass imports"

# No tmp directories
ls /tmp/marketplace /tmp/lsp-indexer 2>/dev/null && echo "ERROR: Temp dirs remain" || echo "OK: Clean"
```
  </action>
  <verify>
    <automated>pnpm build && pnpm test && pnpm check 2>&1 | tail -10</automated>
  </verify>
  <done>
    All 11 packages build with zero warnings. All tests pass. pnpm check (lint + sherif + knip + madge) passes. No circular dependencies. No @chillpass imports. Both new packages (lsp1, erc725) are functional and tested.
  </done>
</task>

</tasks>

<verification>
1. `ls -d packages/*/package.json | wc -l` shows 11 packages
2. `pnpm build` exits 0 with zero warnings across all 11 packages
3. `pnpm test` exits 0 with all tests passing
4. `pnpm check` exits 0 (lint + sherif + knip + madge all pass)
5. `pnpm --filter @chillwhales/lsp1 build && pnpm --filter @chillwhales/lsp1 test` exits 0
6. `pnpm --filter @chillwhales/erc725 build && pnpm --filter @chillwhales/erc725 test` exits 0
7. No `@chillpass` imports in any source file
8. No temporary directories remain
</verification>

<success_criteria>
- @chillwhales/lsp1 package exists with LSP1 typeId constants, types, and guards
- @chillwhales/erc725 package exists with ERC725Y data-key building utilities
- Both packages follow the exact monorepo pattern (shared build config, vitest, tsconfig)
- All 11 packages build, test, and lint cleanly
- lsp-indexer metadata parsing overlap documented in SUMMARY
- Monorepo has zero circular dependencies, zero unused exports, zero lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-external-code-extraction/08-03-SUMMARY.md`

In the SUMMARY, include a section "## lsp-indexer Investigation" documenting:
1. Which handlers use metadata parsing that @chillwhales/* packages could replace
2. Whether any pure utility code was extracted vs created fresh
3. Recommendations for lsp-indexer migration (consuming @chillwhales/* packages)
</output>

---
phase: 03-dependency-monorepo-hygiene
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - package.json
  - packages/*/package.json
  - packages/*/src/*.ts
autonomous: true

must_haves:
  truths:
    - "pnpm knip exits 0 — no unused dependencies, exports, files, or types"
    - "pnpm sherif exits 0 — monorepo package consistency validated"
    - "pnpm madge exits 0 — no inter-package circular dependencies"
    - "pnpm check exits 0 — all hygiene tools pass clean in sequence"
    - "npm install in repo root fails with only-allow enforcement error"
    - "All violations were fixed in code (not suppressed in central config)"
    - "Any ignore comments include a reason explaining the exception"
  artifacts:
    - path: "package.json"
      provides: "Clean root with no unused deps and working preinstall"
      contains: "preinstall"
    - path: "packages/*/package.json"
      provides: "Consistent package metadata per sherif rules"
    - path: "packages/*/src/index.ts"
      provides: "Clean barrel exports with no unused exports"
  key_links:
    - from: "pnpm check"
      to: "check:lint && sherif && knip && madge"
      via: "sequential script execution"
      pattern: "pnpm check:lint && pnpm sherif && pnpm knip && pnpm madge"
    - from: "knip.json"
      to: "packages/*/src/index.ts"
      via: "entry point analysis"
      pattern: "entry.*src/index\\.ts"
---

<objective>
Run all four hygiene tools against the codebase, fix every violation found, and verify a clean slate.

Purpose: The user decision requires zero existing violations before merging — every tool must exit 0. This plan discovers what's broken and fixes it, leaving the repo in a state where `pnpm check` passes clean.
Output: All violations fixed. `pnpm check` exits 0. Clean slate for zero-tolerance enforcement going forward.
</objective>

<execution_context>
@/home/coder/.config/Claude/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dependency-monorepo-hygiene/03-RESEARCH.md
@.planning/phases/03-dependency-monorepo-hygiene/03-CONTEXT.md
@.planning/phases/03-dependency-monorepo-hygiene/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Run knip and fix all violations</name>
  <files>package.json, packages/*/package.json, packages/*/src/*.ts, knip.json</files>
  <action>
  **Run knip to discover all violations:**
  ```bash
  pnpm knip
  ```

  **Analyze and categorize each finding.** knip reports:
  - **Unused dependencies** — dependencies listed in package.json but not imported in code
  - **Unused devDependencies** — devDependencies not used by any config or source file
  - **Unused exports** — exported symbols not imported anywhere in the workspace
  - **Unused files** — source files not imported by any entry point
  - **Unused types** — exported types not referenced anywhere

  **Fix each category systematically:**

  1. **Unused dependencies:** Remove from the relevant package.json `dependencies` or `devDependencies`. Use `pnpm remove <pkg>` in the specific package directory, or edit package.json directly and run `pnpm install`.

  2. **Unused exports:** Remove the export from the source file. If the export is in a barrel `src/index.ts`, also remove the re-export. If the symbol is intentionally public API that has no internal consumers (library packages export for external npm consumers), this should NOT be flagged because `includeEntryExports: false` is set for library packages. If it IS flagged despite this setting, investigate — the knip.json config may need adjustment.

  3. **Unused files:** Either delete the file (if truly dead code) or add it as an entry point in knip.json if it's intentionally standalone.

  4. **Unused types:** Remove the type export, or keep and annotate with `// knip:ignore — {reason}` if the type is part of the public API contract.

  **Handling legitimate exceptions (per user decision):**
  - Exceptions use inline `// knip:ignore — {reason}` comments, NOT central config `ignore` arrays
  - Every ignore MUST include a reason: `// knip:ignore — exported for external npm consumers` or similar
  - Only use ignores as last resort — prefer actually removing unused code

  **Iterate until clean:**
  Run `pnpm knip` after each batch of fixes. Repeat until it exits 0 with no findings.

  **If knip produces false positives related to `catalog:` protocol:**
  Add specific dependencies to `ignoreDependencies` in the relevant workspace config in knip.json. Document why in a JSON comment or nearby code comment.

  **If knip doesn't recognize @chillwhales/config exports correctly:**
  Check that `packages/config` workspace override in knip.json has the right entry files. The config package exports via subpath exports (`./build`, `./vitest`, `./tsconfig`), mapping to `src/build.ts`, `src/vitest.ts`, and `tsconfig.base.json`. Adjust the knip config workspace override if needed.
  </action>
  <verify>
  - `pnpm knip` exits 0 with no output (or only informational messages, no findings)
  - `pnpm knip 2>&1 | grep -c "unused"` shows 0
  - If any `knip:ignore` comments were added: `grep -r "knip:ignore" packages/ --include="*.ts" | head -20` — each must have a reason after the `—`
  </verify>
  <done>pnpm knip exits 0. All unused dependencies removed. All unused exports removed. All unused files removed. Any legitimate exceptions have inline knip:ignore comments with documented reasons.</done>
</task>

<task type="auto">
  <name>Task 2: Run sherif and madge, verify clean slate</name>
  <files>package.json, packages/*/package.json</files>
  <action>
  **Step 1: Run sherif and fix all findings:**
  ```bash
  pnpm sherif
  ```

  sherif checks monorepo consistency rules. With `failOnWarnings: true`, both errors and warnings cause non-zero exit. Common findings in this repo:

  - **multiple-dependency-versions:** Same dependency at different versions across packages. Fix by aligning to the catalog version or adding to the pnpm catalog if not already there.
  - **empty-dependencies:** Empty `{}` blocks in package.json. Remove the empty block.
  - **types-in-dependencies:** `@types/*` packages in `dependencies` instead of `devDependencies`. Move to devDependencies.
  - **unordered-dependencies:** Dependencies not alphabetically sorted. Sort them.
  - **root-package-dependencies:** Root package.json has `dependencies` (should only have `devDependencies`). Move or remove.

  Fix each finding. Iterate: run `pnpm sherif` → fix → repeat until exit 0.

  **If sherif reports false positives with `catalog:` versions:**
  The `catalog:` protocol should resolve correctly in sherif. If it doesn't, use sherif's `--ignore-dependency` flag for the specific package or add exceptions to the `"sherif"` config in package.json. Document why.

  **Step 2: Run madge circular dependency check:**
  ```bash
  pnpm madge
  ```

  This runs `scripts/check-circular.mjs` which:
  - Executes madge with `--circular --json` across all `packages/*/src`
  - Filters to inter-package cycles only (ignoring intra-package cycles)
  - Reports full file-level cycle paths

  **If inter-package circular dependencies are found:**
  These are genuine architectural issues. The current internal dependency graph (from ARCHITECTURE.md) shows no cycles:
  ```
  lsp4, lsp6 → utils
  lsp3, lsp4, lsp23, lsp29 → lsp2
  lsp30 (standalone, no workspace deps)
  ```
  If madge reports cycles, investigate. It likely means an import was added that creates a cycle. Fix by restructuring the import (extract shared code to `utils` or `lsp2`, or use dependency injection).

  **If madge has trouble with TypeScript resolution:**
  Try using `--ts-config ./packages/config/tsconfig.base.json` instead of `./packages/utils/tsconfig.json`. The script may need adjustment.

  **Step 3: Test pnpm enforcement:**
  Verify the preinstall hook works by simulating:
  ```bash
  # This should fail (we're running via pnpm, testing the mechanism):
  node -e "const {execSync} = require('child_process'); try { execSync('npx only-allow npm', {stdio:'pipe'}); console.log('FAIL: should have rejected npm'); process.exit(1); } catch(e) { console.log('PASS: only-allow correctly rejected npm'); }"
  ```

  **Step 4: Run the full umbrella check:**
  ```bash
  pnpm check
  ```

  This runs: `pnpm check:lint && pnpm sherif && pnpm knip && pnpm madge`
  ALL four must pass. If any fails, fix the issue and re-run.

  **Step 5: Verify build and tests still pass:**
  ```bash
  pnpm build && pnpm test
  ```

  Removing unused deps/exports must not break builds or tests. If anything fails, the removal was incorrect — restore and investigate.
  </action>
  <verify>
  - `pnpm sherif` exits 0
  - `pnpm madge` exits 0 (no inter-package circular deps)
  - `pnpm check` exits 0 (all hygiene tools pass)
  - `pnpm build` exits 0 (no build regressions)
  - `pnpm test` exits 0 (no test regressions)
  </verify>
  <done>pnpm sherif exits 0 (monorepo consistent). pnpm madge exits 0 (no inter-package circular deps). pnpm check exits 0 (all tools pass clean). pnpm build and pnpm test still pass. Zero existing violations — clean slate established.</done>
</task>

</tasks>

<verification>
Run all checks in sequence to verify complete phase success:
```bash
pnpm check    # umbrella: biome + sherif + knip + madge
pnpm build    # no regressions
pnpm test     # no regressions
```

Additionally verify pnpm enforcement manually:
- The `preinstall` script in package.json contains `npx only-allow pnpm`
- Running with a non-pnpm manager would fail
</verification>

<success_criteria>
- `pnpm knip` exits 0 — no unused dependencies, exports, files, or types (QUAL-04)
- `pnpm sherif` exits 0 — monorepo package consistency validated (QUAL-05)
- `pnpm madge` exits 0 — no inter-package circular dependencies (BUILD-05)
- `pnpm check` exits 0 — all hygiene tools pass in the umbrella command
- preinstall hook blocks npm/yarn (QUAL-06)
- `pnpm build` still passes — no regressions from removing unused code
- `pnpm test` still passes — no regressions from removing unused code
- Any exception comments include documented reasons
</success_criteria>

<output>
After completion, create `.planning/phases/03-dependency-monorepo-hygiene/03-02-SUMMARY.md`
</output>
